================================================
File: README.md
================================================
AlphaWave


================================================
File: LICENSE
================================================
MIT License

Copyright (c) 2024 Sim Kim Wee

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


================================================
File: main.py
================================================
import logging
import threading
import time
import os
from dotenv import load_dotenv
from pathlib import Path

from infrastructure.utility.Adapters.alpaca_adapter import AlpacaAdapter
from infrastructure.utility.Adapters.yfinance_adapter import YfinanceAdapter
from services.position import Position
from infrastructure.interface.currencyWeightsEnum import CurrencyWeights
from services.asset import Asset

from infrastructure.utility.Adapters.binance_adapter import BinanceAdapter
from services.portfolio import Portfolio
from infrastructure.utility.Indicators import ATR, Bollinger_Bands, Fibonacci, MACD, RSI, Stochastic_Oscillator
from services.wallet import Wallet

if __name__ == '__main__':
    load_dotenv()

    alpaca_api_key = os.getenv("ALPACA_API_KEY")
    alpaca_api_secret = os.getenv("ALPACA_API_SECRET")
    binance_api_key = os.getenv("BINANCE_API_KEY")
    binance_api_secret = os.getenv("BINANCE_API_SECRET")

    # logging configuration
    logging.basicConfig(format='%(asctime)s [%(threadName)-12.12s] [%(levelname)-5.5s]  %(message)s',
                        level=logging.INFO)

    # Declare right type of adapter to use
    api_adapter = BinanceAdapter(binance_api_key, binance_api_secret)
    hedging_adapter = AlpacaAdapter(alpaca_api_key, alpaca_api_secret)

    # Reflect platform
    if isinstance(api_adapter, BinanceAdapter):
        data, assets, positions = api_adapter.get_account_info()

        # Create Wallet
        wallet = Wallet(
            data['feeTier'],
            data['totalWalletBalance'],
            data['totalUnrealizedProfit'],
            data['totalMarginBalance'],
            data['totalCrossWalletBalance'],
            data['availableBalance'],
            data['maxWithdrawAmount'],
        )

        # Binance api to fetch and map into dataframe for consolidation of data
        response = api_adapter.get_initial_df(3600, 15)

        temp_assets_list = []

        # Loop through each key e.g. (BTCUSDT, BNBUSDT etc.) and create TA's Positions automatically.
        for item in response.keys():

            temp_position_list = []

            # Generate & add in TAs into each asset class
            TAs = {
                'atr': ATR.ATR().calculate_historical_readings(response[item].copy(), 5),
                'bollinger': Bollinger_Bands.BollingerBands().calculate_historical_readings(response[item].copy(), 5),
                'fibonacci': Fibonacci.FIBONACCI().calculate_historical_readings(response[item].copy(), 5),
                'macd': MACD.MACD().calculate_historical_readings(response[item].copy(), 5),
                'rsi': RSI.RSI().calculate_historical_readings(response[item].copy(), 5),
                'stochastic': Stochastic_Oscillator.StochasticOscillator().calculate_historical_readings(
                    response[item].copy(), 5)}

            # Map current positions to system
            for position in positions:
                if position['symbol'] == item:
                    temp_position = Position(
                        symbol=item,
                        initialMargin=float(position['initialMargin']),
                        maintMargin=float(position['maintMargin']),
                        unrealizedProfit=float(position['unrealizedProfit']),
                        positionInitialMargin=float(position['positionInitialMargin']),
                        openOrderInitialMargin=float(position['openOrderInitialMargin']),
                        leverage=float(position['leverage']),
                        isolated=bool(position['isolated']),
                        entryPrice=float(position['entryPrice']),
                        maxNotional=float(position['maxNotional']),
                        bidNotional=float(position['bidNotional']),
                        askNotional=float(position['askNotional']),
                        positionSide=str(position['positionSide']),
                        positionAmt=float(position['positionAmt']),
                        updateTime=float(position['updateTime'])
                    )
                    temp_position_list.append(temp_position)

            temp_asset = Asset(item, CurrencyWeights[item].value, positions=temp_position_list, TAs=TAs)
            temp_assets_list.append(temp_asset)

        # Assign portfolio asset allocation
        portfolio = Portfolio(assets=temp_assets_list, wallet=wallet)

        # DEBUGGING PURPOSE
        # portfolio.show_specs()

        while True:
            portfolio.activate_monitoring(api_adapter)
            time.sleep(60)

    elif isinstance(api_adapter, YfinanceAdapter):

        # data, assets, positions = api_adapter.get_account_info()

        # Create Wallet
        wallet = Wallet(
            0,
            1000000,
            0,
            0,
            0,
            1000000,
            1000000,
        )

        # Binance api to fetch and map into dataframe for consolidation of data
        response = api_adapter.get_asset_data()

        print(response)

        temp_assets_list = []

        # Loop through each key e.g. (BTCUSDT, BNBUSDT etc.) and create TA's Positions automatically.
        for item in response.keys():
            temp_position_list = []

            # Generate & add in TAs into each asset class
            TAs = {
                'atr': ATR.ATR().calculate_historical_readings(response[item].copy(), 5),
                'bollinger': Bollinger_Bands.BollingerBands().calculate_historical_readings(response[item].copy(), 5),
                'fibonacci': Fibonacci.FIBONACCI().calculate_historical_readings(response[item].copy(), 5),
                'macd': MACD.MACD().calculate_historical_readings(response[item].copy(), 5),
                'rsi': RSI.RSI().calculate_historical_readings(response[item].copy(), 5),
                'stochastic': Stochastic_Oscillator.StochasticOscillator().calculate_historical_readings(
                    response[item].copy(), 5)
            }

            temp_asset = Asset(item, CurrencyWeights[item].value, positions=[], TAs=TAs)
            temp_assets_list.append(temp_asset)

        # Assign portfolio asset allocation
        portfolio = Portfolio(assets=temp_assets_list, wallet=wallet)

        # DEBUGGING PURPOSE
        portfolio.show_specs()

        # Activate Monitoring
        threading.Timer(60, portfolio.activate_monitoring(api_adapter)).start()


================================================
File: infrastructure/interface/IAdapter.py
================================================
import threading
from abc import ABC, abstractmethod


class GenericAdapter(ABC):

    @abstractmethod
    def __init__(self):
        raise NotImplementedError

    @abstractmethod
    def get_credentials(self):
        raise NotImplementedError

    @abstractmethod
    def get_account_info(self):
        raise NotImplementedError

    @abstractmethod
    def get_asset_data(self):
        raise NotImplementedError

    @abstractmethod
    def transact_assets(self, symbol: str, qty: float, side: str, position_side: str):
        raise NotImplementedError

    @abstractmethod
    def __del__(self):
        raise NotImplementedError

================================================
File: infrastructure/interface/Iasset.py
================================================
from abc import ABC, abstractmethod
from infrastructure.interface.currencyWeightsEnum import CurrencyWeights
from services.position import Position


class IAsset(ABC):

    @abstractmethod
    def __init__(self, name: str, weight: CurrencyWeights, positions: [Position], TAs: {}):
        raise NotImplementedError

    @abstractmethod
    def asset_info(self):
        raise NotImplementedError

    @abstractmethod
    def get_positions(self):
        raise NotImplementedError

    @abstractmethod
    def set_weight(self, weight: float):
        raise NotImplementedError

    @abstractmethod
    def get_weight(self):
        raise NotImplementedError

    @abstractmethod
    def set_current_asset_weightage(self, weight: float):
        raise NotImplementedError

    def get_current_asset_weightage(self):
        raise NotImplementedError

    @abstractmethod
    def __del__(self):
        raise NotImplementedError


================================================
File: infrastructure/interface/Iindicator.py
================================================
from abc import ABC, abstractmethod
import pandas as pd


class IIndicator(ABC):

    @staticmethod
    def calculate_historical_readings():
        raise NotImplementedError

    @staticmethod
    @abstractmethod
    def calculate():
        raise NotImplementedError

    @staticmethod
    @abstractmethod
    def generate_signals():
        raise NotImplementedError


================================================
File: infrastructure/interface/Iportfolio.py
================================================
from abc import ABC, abstractmethod


class IPortfolio(ABC):

    @abstractmethod
    def __init__(self):
        raise NotImplementedError

    @abstractmethod
    def filter_signals(self, indicators: []):
        raise NotImplementedError

    @abstractmethod
    def show_specs(self):
        raise NotImplementedError

    @abstractmethod
    def generate_signals(self):
        raise NotImplementedError

    @abstractmethod
    def compute_realized_allocation(self, signals: {}):
        raise NotImplementedError

    @abstractmethod
    def transact_assets(self, symbol: str, qty: int, side: str, position_side: str):
        raise NotImplementedError

    @abstractmethod
    def __del__(self):
        raise NotImplementedError


================================================
File: infrastructure/interface/currencyWeightsEnum.py
================================================
from enum import Enum


class CurrencyWeights(Enum):
    BTCUSDT = 0.23
    ETHUSDT = 2.37
    BNBUSDT = 22.06
    ZECUSDT = 3.26
    LTCUSDT = 71.78

    @classmethod
    def list(cls):
        return list(map(lambda c: c.name, cls))



================================================
File: infrastructure/interface/hedgingAssetsEnum.py
================================================
from enum import Enum


class HedgingAssets(Enum):
    BTCUSDT = 'IWV'
    ETHUSDT = 'XLF'
    BNBUSDT = 'XLF'
    ZECUSDT = 'XTL'
    LTCUSDT = 'XTL'

    @classmethod
    def list(cls):
        return list(map(lambda c: c.name, cls))



================================================
File: infrastructure/interface/indicatorsEnum.py
================================================
from enum import Enum
from infrastructure.utility.Indicators.ATR import ATR
from infrastructure.utility.Indicators.MACD import MACD
from infrastructure.utility.Indicators.RSI import RSI
from infrastructure.utility.Indicators.Fibonacci import FIBONACCI
from infrastructure.utility.Indicators.Bollinger_Bands import BollingerBands
from infrastructure.utility.Indicators.Stochastic_Oscillator import StochasticOscillator


class Indicators(Enum):
    ATR = ATR()
    RSI = RSI()
    Stochastic_Oscillator = StochasticOscillator()
    MACD = MACD()
    Bollinger_Bands = BollingerBands()
    Fibonacci = FIBONACCI()

    @classmethod
    def list(cls):
        return list(map(lambda c: c.name, cls))

================================================
File: infrastructure/interface/Binance/Iwallet.py
================================================
from abc import ABC, abstractmethod


class IWallet(ABC):

    @abstractmethod
    def __init__(self):
        raise NotImplementedError

    @abstractmethod
    def update_account(self):
        raise NotImplementedError

    @abstractmethod
    def get_assets(self):
        raise NotImplementedError

    @abstractmethod
    def get_notional(self):
        raise NotImplementedError

    @abstractmethod
    def __del__(self):
        raise NotImplementedError


================================================
File: infrastructure/utility/Adapters/alpaca_adapter.py
================================================
import logging
from alpaca.data import StockLatestTradeRequest
from infrastructure.interface.IAdapter import GenericAdapter
from alpaca.trading.client import TradingClient
from alpaca.trading.requests import MarketOrderRequest, GetOrdersRequest
from alpaca.trading.enums import OrderSide, TimeInForce, QueryOrderStatus
from alpaca.common.exceptions import APIError
from alpaca.data.historical import StockHistoricalDataClient


class AlpacaAdapter(GenericAdapter, object):
    instance = None

    def __init__(self, api_key, api_secret):
        self._api_key = api_key
        self._secret_key = api_secret
        self._hedging_client = TradingClient(self._api_key, self._secret_key)
        self._hedging_market = StockHistoricalDataClient(self._api_key, self._secret_key)

    def get_credentials(self):
        return self._api_key, self._secret_key

    def get_account_info(self):
        response = self._hedging_client.get_account()
        return response

    def get_current_ticker_data(self, symbol: str):
        request_params = StockLatestTradeRequest(
            symbol_or_symbols=symbol
        )
        response = self._hedging_market.get_stock_latest_trade(request_params)[symbol].price
        return float(response)

    def get_asset_data(self, symbol):
        return self._hedging_client.get_asset(symbol_or_asset_id=symbol)

    def transact_assets(self, symbol: str, qty: float, side: str):
        try:
            # preparing orders
            market_order_data = MarketOrderRequest(
                symbol_or_symbols=symbol,
                qty=qty,
                type='MARKET',
                side=OrderSide.BUY if side == 'BUY' else OrderSide.SELL,
                time_in_force=TimeInForce.DAY
            )

            # Market order
            market_order = self._hedging_client.submit_order(
                order_data=market_order_data
            )

            return market_order
        except APIError as e:
            logging.error("Trade Execution Error: " + str(e.response))
            pass

    def get_all_orders(self, side: str):
        try:
            # params to filter orders by
            request_params = GetOrdersRequest(
                status=QueryOrderStatus.OPEN,
                side=OrderSide.SELL
            )

            # orders that satisfy params
            return self._hedging_client.get_orders(filter=request_params)
        except APIError as e:
            logging.error("Trade Execution Error: " + str(e.response))
            pass

    def cancel_all_orders(self):
        try:
            return self._hedging_client.cancel_orders()
        except APIError as e:
            logging.error("Trade Execution Error: " + str(e.response))
            pass

    def get_all_positions(self):
        try:
            return self._hedging_client.get_all_positions()
        except APIError as e:
            logging.error("Trade Execution Error: " + str(e.response))
            pass

    def close_all_positions(self):
        try:
            return self._hedging_client.close_all_positions(cancel_orders=True)
        except APIError as e:
            logging.error("Trade Execution Error: " + str(e.response))
            pass

    def __del__(self):
        pass

    def __new__(cls, *args, **kwargs):
        if not isinstance(cls.instance, cls):
            cls.instance = object.__new__(cls)
        return cls.instance


================================================
File: infrastructure/utility/Adapters/binance_adapter.py
================================================
import logging
import time
import calendar
import pandas as pd
from datetime import datetime as dt

from binance.error import ClientError
from infrastructure.interface.currencyWeightsEnum import CurrencyWeights
from infrastructure.interface.IAdapter import GenericAdapter
from binance.um_futures import UMFutures


class BinanceAdapter(GenericAdapter, object):
    instance = None

    def __init__(self, api_key, api_secret):
        self._base_url = 'https://testnet.binancefuture.com'
        self._api_key = api_key
        self._secret_key = api_secret
        self._futures_client = UMFutures(key=self._api_key, secret=self._secret_key, base_url=self._base_url)

    def get_credentials(self):
        return self._base_url, self._api_key, self._secret_key

    def get_account_info(self):
        response = self._futures_client.account()
        return response, response['assets'], response['positions']

    def get_asset_data(self):
        pass

    def get_market_positions(self, symbol: str = None):
        try:
            response = self._futures_client.get_position_risk(symbol=symbol, recvWindow=6000)
            logging.info(response)
            return response
        except ClientError as error:
            logging.error(
                "Found error. status: {}, error code: {}, error message: {}".format(
                    error.status_code, error.error_code, error.error_message
                )
            )

    def get_ticker_price(self, symbol: str):
        return float(self._futures_client.ticker_price(symbol=symbol)['price'])

    def get_market_data(self, interval: str):
        temp_dict = {}
        pairs = CurrencyWeights.list()

        temp_dict[pairs[0]] = self._futures_client.klines(pairs[0], interval)[-1][1:6]
        temp_dict[pairs[1]] = self._futures_client.klines(pairs[1], interval)[-1][1:6]
        temp_dict[pairs[2]] = self._futures_client.klines(pairs[2], interval)[-1][1:6]
        temp_dict[pairs[3]] = self._futures_client.klines(pairs[3], interval)[-1][1:6]
        temp_dict[pairs[4]] = self._futures_client.klines(pairs[4], interval)[-1][1:6]

        temp_dict = {key: list(map(float, value)) for key, value in temp_dict.items()}

        return temp_dict

    def get_specific_market_data(self, interval: str, pair_name: str):
        return list(map(float, self._futures_client.klines(symbol=pair_name, interval=interval)[-1][1:6]))

    def get_initial_df(self, seconds, interval):
        dict_temp = {}

        # Generate a list of dataframes for manipulation
        for pair in CurrencyWeights.list():
            dict_temp[pair] = pd.DataFrame(columns=['Open', 'High', 'Low', 'Close', 'Volume'])

        initial_interval = interval

        while interval:
            try:
                logging.info(f'Getting initial data for T + {initial_interval - interval}')

                response = self.get_market_data("1h")
                time_now = calendar.timegm((dt.utcnow()).utctimetuple())

                for pair in CurrencyWeights.list():
                    dict_temp[pair].loc[time_now] = response.get(pair)

                interval -= 1
            except Exception as e:
                raise e
            time.sleep(seconds)

        # Completed
        logging.info(f'Finished getting initial data for T + {initial_interval}')
        print(dict_temp)
        return dict_temp

    def get_current_df_row(self, dict_temp: {}, pair) -> dict:
        final_table_columns = ['Open', 'High', 'Low', 'Close', 'Volume']
        response = self.get_specific_market_data("1h", pair)
        time_now = calendar.timegm((dt.utcnow()).utctimetuple())

        for x, y in dict_temp.items():
            dict_temp[x] = dict_temp[x].drop(index=dict_temp[x].index[0], axis=0)
            dict_temp[x] = dict_temp[x].drop(columns=[col for col in dict_temp[x] if col not in final_table_columns])
            dict_temp[x].loc[time_now] = response

        return dict_temp

    def __del__(self):
        pass

    def transact_assets(self, symbol: str, qty: float, side: str, position_side: str):

        try:
            response = self._futures_client.new_order(
                symbol=symbol,
                side=side,
                positionSide=position_side,
                type="MARKET",
                quantity=str(qty))
            logging.info('Sent Order: ', response)
            return response
        except Exception as error:
            logging.error(
                "Found error. status: {}, error code: {}, error message: {}".format(
                    error.status_code, error.error_code, error.error_message
                )
            )
            return error.__str__()

    def __new__(cls, *args, **kwargs):
        if not isinstance(cls.instance, cls):
            cls.instance = object.__new__(cls)
        return cls.instance


================================================
File: infrastructure/utility/Adapters/yfinance_adapter.py
================================================
import logging
import time
import calendar
import pandas as pd
from datetime import datetime as dt
from infrastructure.interface.currencyWeightsEnum import CurrencyWeights
from infrastructure.interface.IAdapter import GenericAdapter
from pandas_datareader import data as pdr
import yfinance as yf
yf.pdr_override()


class YfinanceAdapter(GenericAdapter, object):

    def __init__(self):
        self._dataframes = {}
        self._df_names = CurrencyWeights.list()

        start = dt(2019, 3, 31)
        end = dt(2024, 3, 31)

        self._dataframes[self._df_names[0]] = pdr.get_data_yahoo("BTC-USD", start, end, progress=False)
        self._dataframes[self._df_names[1]] = pdr.get_data_yahoo("ETH-USD", start, end, progress=False)
        self._dataframes[self._df_names[2]] = pdr.get_data_yahoo("BNB-USD", start, end, progress=False)
        self._dataframes[self._df_names[3]] = pdr.get_data_yahoo("ZEC-USD", start, end, progress=False)
        self._dataframes[self._df_names[4]] = pdr.get_data_yahoo("LTC-USD", start, end, progress=False)

    def get_credentials(self):
        pass

    def get_account_info(self):
        pass

    def get_asset_data(self):
        return self._dataframes

    def transact_assets(self, symbol: str, qty: float, side: str, position_side: str):
        pass

    def __del__(self):
        pass


================================================
File: infrastructure/utility/Indicators/ATR.py
================================================
from infrastructure.interface.Iindicator import IIndicator
import pandas as pd


class ATR(IIndicator):

    @staticmethod
    def calculate_historical_readings(dataframe: pd.DataFrame, window: int) -> pd.DataFrame:

        dataframe["Previous Close"] = dataframe["Close"].shift(1)
        true_range = dataframe.apply(lambda row: max(row["High"] - row["Low"], abs(row["High"] - row["Previous Close"]),
                                                     abs(row["Low"] - row["Previous Close"])), axis=1)

        rolling_true_range = true_range.rolling(window=window).sum()
        average_volatility = rolling_true_range * (1 / window)
        dataframe["Price_Diff"] = dataframe["Close"] - dataframe["Open"]
        dataframe["Next_Avg_Volatility"] = average_volatility.shift(-1)

        return dataframe

    @staticmethod
    def generate_signals(dataframe: pd.DataFrame) -> pd.Series:

        # Initialize signals
        signals = pd.Series(0, index=dataframe.index, dtype='int')

        # Generate signals using vectorized operations
        signals[(dataframe["Price_Diff"] > dataframe['Next_Avg_Volatility'])] = 1.0
        signals[(dataframe["Price_Diff"] < dataframe['Next_Avg_Volatility'])] = -1.0

        return signals

    @staticmethod
    def calculate(dataframe: pd.DataFrame, window: int):
        pass

================================================
File: infrastructure/utility/Indicators/Bollinger_Bands.py
================================================
from infrastructure.interface.Iindicator import IIndicator
import pandas as pd


class BollingerBands(IIndicator):

    @staticmethod
    def calculate_historical_readings(dataframe: pd.DataFrame, window: int) -> pd.DataFrame:

        # Calculate the middle band (simple moving average)
        dataframe['Middle_Band'] = dataframe.iloc[:, 0].rolling(window=window).mean()

        # Calculate the standard deviation
        std = dataframe.iloc[:, 0].rolling(window=window).std()

        # Calculate the upper band
        dataframe['Upper_Band'] = dataframe['Middle_Band'] + (std * 2)

        # Calculate the lower band
        dataframe['Lower_Band'] = dataframe['Middle_Band'] - (std * 2)

        return dataframe

    @staticmethod
    def generate_signals(dataframe: pd.DataFrame, column: str) -> pd.Series:

        signals = pd.Series(index=dataframe.index, dtype=int)

        # Generate signals based on Bollinger Band conditions
        for index, row in dataframe.iterrows():
            if row[column] < row['Lower_Band']:
                signals.loc[index] = 1  # Buy signal
            elif row[column] > row['Upper_Band']:
                signals.loc[index] = -1  # Sell signal
            else:
                signals.loc[index] = 0  # Hold

        return signals

    @staticmethod
    def calculate(self):
        pass


================================================
File: infrastructure/utility/Indicators/Fibonacci.py
================================================
from infrastructure.interface.Iindicator import IIndicator
import pandas as pd


class FIBONACCI(IIndicator):
    @staticmethod
    def calculate_historical_readings(dataframe: pd.DataFrame, window: int) -> pd.DataFrame:

        # Get the single column name automatically assuming there's only one column
        column_name = dataframe.columns[0]

        # Find the maximum and minimum close price
        max_price = dataframe[column_name].max()
        min_price = dataframe[column_name].min()

        # Calculate Fibonacci Levels considering the maximum and minimum price
        diff = max_price - min_price
        levels = {
            'Level_23.6%': max_price - diff * 0.236,
            'Level_38.2%': max_price - diff * 0.382,
            'Level_50%': max_price - diff * 0.5,
            'Level_61.8%': max_price - diff * 0.618,
        }

        # Append Fibonacci retracement levels to the DataFrame
        for level, price in levels.items():
            dataframe[level] = price

        return dataframe

    @staticmethod
    def generate_signals(dataframe: pd.DataFrame, column_name: str) -> pd.Series:
        signals = pd.Series(index=dataframe.index, dtype=int)  # Initialize the signals Series

        # Calculate the maximum and minimum to re-establish the Fibonacci levels
        max_price = dataframe[column_name].max()
        min_price = dataframe[column_name].min()
        diff = max_price - min_price
        levels = {
            'Level_23.6%': max_price - diff * 0.236,
            'Level_38.2%': max_price - diff * 0.382,
            'Level_50%': max_price - diff * 0.5,
            'Level_61.8%': max_price - diff * 0.618,
        }

        # Determine if prices rebound from levels (simplified logic)
        for i in range(1, len(dataframe)):
            previous_price = dataframe[column_name].iloc[i - 1]
            current_price = dataframe[column_name].iloc[i]
            for level, price in levels.items():
                if previous_price < price <= current_price:  # Crossing up a level
                    signals.iloc[i] = 1  # Potential buy signal
                elif previous_price > price >= current_price:  # Crossing down a level
                    signals.iloc[i] = -1  # Potential sell signal
                else:
                    signals.iloc[i] = 0

        return signals

    @staticmethod
    def calculate():
        pass

================================================
File: infrastructure/utility/Indicators/MACD.py
================================================
from infrastructure.interface.Iindicator import IIndicator
import pandas as pd


class MACD(IIndicator):

    @staticmethod
    def calculate_historical_readings(dataframe: pd.DataFrame, window: int) -> pd.DataFrame:

        # Assume that the DataFrame contains only one column
        column_name = dataframe.columns[0]  # Dynamically get the name of the column

        # Calculate the short-term exponential moving average (EMA)
        short_ema = dataframe[column_name].ewm(span=window * (12 / 26), adjust=False).mean()

        # Calculate the long-term exponential moving average (EMA)
        long_ema = dataframe[column_name].ewm(span=window, adjust=False).mean()

        # Calculate the MACD line
        dataframe['MACD'] = short_ema - long_ema  # Name change to not use column_name in output

        # Calculate the signal line
        dataframe['Signal'] = dataframe['MACD'].ewm(span=9, adjust=False).mean()

        return dataframe

    @staticmethod
    def generate_signals(dataframe: pd.DataFrame) -> pd.Series:
        signals = pd.Series(index=dataframe.index, dtype=int)  # Initialize the signals Series

        # Iterate through the DataFrame to generate signals
        for index, row in dataframe.iterrows():
            if row['MACD'] > row['Signal']:
                signals.loc[index] = 1  # Buy signal if MACD crosses above the signal line
            elif row['MACD'] < row['Signal']:
                signals.loc[index] = -1  # Sell signal if MACD crosses below the signal line
            else:
                signals.loc[index] = 0  # Hold if there's no crossover

        return signals

    @staticmethod
    def calculate():
        pass

================================================
File: infrastructure/utility/Indicators/Optimal_Rolling_Window.py
================================================
from infrastructure.interface.Iindicator import IIndicator
from statsmodels.tsa.stattools import pacf
import pandas as pd

class Optimal_Rolling_Window(IIndicator):

    def __init__(self, dataframe: pd.dataframe, significance_level: float = 0.05):
        super().__init__()
        self.dataframe = dataframe
        self.significance_level = significance_level

    def calculate_optimal_rolling_window(self):
        max_lags = min(40, len(self.dataframe) // 3)  # Adjust the denominator as needed
        pacf_values = pacf(self.dataframe, nlags=max_lags, alpha=self.significance_level)
        
        # The pacf function returns both the pacf values and the confidence intervals
        pacf_vals, confint = pacf_values
        
        # Find the last significant lag where PACF is outside the confidence bounds
        significant_lags = [i for i in range(len(pacf_vals)) if abs(pacf_vals[i]) > confint[i][1] - pacf_vals[i]]
        
        if significant_lags:
            optimal_lag = max(significant_lags)
        else:
            optimal_lag = 1  # Default to 1 if no significant lags are found
    
        return optimal_lag
    
    def __del__(self):
        # return super().__del__()
        pass




================================================
File: infrastructure/utility/Indicators/RSI.py
================================================
from infrastructure.interface.Iindicator import IIndicator
import pandas as pd


class RSI(IIndicator):

    @staticmethod
    def calculate_historical_readings(dataframe: pd.DataFrame, window: int) -> pd.DataFrame:
        # Assume the data is in the first column if not explicitly provided
        column_name = dataframe.columns[0]  # Automatically get the column name

        # Calculate price changes
        delta = dataframe[column_name].diff()

        # Separate gains and losses
        gain = delta.where(delta > 0, 0).fillna(0)
        loss = -delta.where(delta < 0, 0).fillna(0)

        # Calculate the exponential moving average of gains and losses
        avg_gain = gain.ewm(com=window - 1, min_periods=window).mean()
        avg_loss = loss.ewm(com=window - 1, min_periods=window).mean()

        # Calculate the RS
        rs = avg_gain / avg_loss

        # Calculate the RSI
        rsi = 100 - (100 / (1 + rs))

        # Append the RSI to the DataFrame
        dataframe['RSI'] = rsi

        return dataframe

    @staticmethod
    def generate_signals(dataframe: pd.DataFrame, lower: int, upper: int) -> pd.Series:
        signals = pd.Series(index=dataframe.index, dtype=int)  # Initialize the signals Series

        # No need to convert to DataFrame, assuming df already includes an 'RSI' column
        for index, row in dataframe.iterrows():
            if row['RSI'] < lower:
                signals.loc[index] = 1  # Buy signal
            elif row['RSI'] > upper:
                signals.loc[index] = -1  # Sell signal
            else:
                signals.loc[index] = 0  # Hold

        return signals

    @staticmethod
    def calculate():
        pass


================================================
File: infrastructure/utility/Indicators/Stochastic_Oscillator.py
================================================
from infrastructure.interface.Iindicator import IIndicator
import pandas as pd


class StochasticOscillator(IIndicator):
    @staticmethod
    def calculate_historical_readings(dataframe: pd.DataFrame, window: int) -> pd.DataFrame:
        dataframe["Lowest_Low"] = dataframe["Low"].rolling(window=window).min()
        dataframe["Highest_High"] = dataframe["High"].rolling(window=window).max()
        dataframe["Stochastic_Osc"] = (dataframe["Close"].shift(1) - dataframe["Lowest_Low"]) / (
                    dataframe["Highest_High"] - dataframe["Lowest_Low"])

        return dataframe

    @staticmethod
    def generate_signals(dataframe: pd.DataFrame) -> pd.Series:
        # Convert Series to DataFrame if necessary
        if isinstance(dataframe, pd.Series):
            dataframe = dataframe.to_frame(name='Stochastic_Osc')  # Assuming the series contains Stochastic Oscillator values

        # Initialize signals with 0 indicating no action
        signals = pd.Series(0, index=dataframe.index, dtype='int')

        # Assign buy signals where the stochastic oscillator is below 0.2
        signals[dataframe["Stochastic_Osc"] < 0.2] = 1.0  # Indicates a buy signal

        # Assign sell signals where the stochastic oscillator is above 0.8
        signals[dataframe["Stochastic_Osc"] > 0.8] = -1.0  # Indicates a sell signal

        return signals

    @staticmethod
    def calculate():
        pass


================================================
File: services/asset.py
================================================
import datetime
from infrastructure.interface.Iasset import IAsset
from services.position import Position
from infrastructure.interface.currencyWeightsEnum import CurrencyWeights


class Asset(IAsset, object):

    def __init__(self, name: str, weight: CurrencyWeights, positions: [Position], TAs: dict):
        self._name = name
        self._weight = weight
        self._positions = positions
        self.current_asset_weights = None
        self._date_created = datetime.datetime.now()
        self._date_modified = datetime.datetime.now()
        self.TAs = TAs

    def asset_info(self):
        return self._name, self._weight, self._positions, self.current_asset_weights, self.TAs

    def get_positions(self):
        return self._positions

    def get_name(self):
        return self._name

    def get_positions(self):
        return self._positions

    def get_name(self):
        return self._name

    def set_weight(self, weight: CurrencyWeights) -> None:
        self._weight = weight

    def get_weight(self) -> CurrencyWeights:
        return self._weight

    def set_indicators(self, indicators: {}) -> None:
        self.TAs = indicators

    def get_indicators(self) -> dict:
        return self.TAs

    def set_current_asset_weightage(self, weight: float):
        self.current_asset_weights = weight

    def get_current_asset_weightage(self) -> float:
        return self.current_asset_weights

    def __del__(self):
        pass



================================================
File: services/portfolio.py
================================================
import datetime
import logging
import threading

from infrastructure.interface.currencyWeightsEnum import CurrencyWeights
from infrastructure.interface.hedgingAssetsEnum import HedgingAssets
from infrastructure.utility.Adapters.alpaca_adapter import AlpacaAdapter
from infrastructure.utility.Adapters.yfinance_adapter import YfinanceAdapter
from infrastructure.utility.Indicators import Bollinger_Bands, Fibonacci, Stochastic_Oscillator
from infrastructure.utility.Indicators.ATR import ATR
from infrastructure.utility.Indicators.MACD import MACD
from infrastructure.utility.Indicators.RSI import RSI
from infrastructure.utility.Indicators.Fibonacci import FIBONACCI
from infrastructure.utility.Indicators.Bollinger_Bands import BollingerBands
from infrastructure.utility.Indicators.Stochastic_Oscillator import StochasticOscillator
from services.asset import Asset
from services.wallet import Wallet
from infrastructure.interface.Iportfolio import IPortfolio
from infrastructure.utility.Adapters.binance_adapter import BinanceAdapter
from infrastructure.utility.Indicators.ATR import ATR


class Portfolio(IPortfolio):

    def __init__(self, assets: [Asset], wallet: Wallet):
        self.combined_signals = []
        self.assets = assets
        self.wallet = wallet

    def get_asset(self):
        return self.assets

    def get_wallet(self):
        return self.wallet

    def set_wallet(self, wallet: Wallet):
        self.wallet = wallet

    def show_specs(self):
        print("Wallet Data: ")
        print(self.wallet)
        for asset in self.assets:
            name, weight, position, current_asset, ta = asset.asset_info()
            print("Asset Name: ", name)
            print("Asset Weight: ", weight)
            print("Asset Positions: ")
            print(position)
            print("Asset Current weight: ", current_asset)
            print("Asset Indicators: ")
            for name, df in ta.items():
                print('TA Name: ', name)
                print('TA Value: ')
                print(df)

    def generate_signals(self):
        overall_signals = {}
        for asset in self.assets:

            indicators = asset.get_indicators()
            name = asset.get_name()

            # Consolidate values in list
            temp = list(map(int, [
                ATR().generate_signals(indicators['atr']).iloc[-1],
                RSI().generate_signals(indicators['rsi'], 30, 70).iloc[-1],
                MACD().generate_signals(indicators['macd']).iloc[-1],
                FIBONACCI().generate_signals(indicators['fibonacci'], 'Close').iloc[-1],
                BollingerBands().generate_signals(indicators['bollinger'], 'Close').iloc[-1],
                StochasticOscillator().generate_signals(indicators['stochastic']).iloc[-1]
            ]))

            print("Asset Name: " + name)
            print(temp)

            # Compute buy/sell/hold for particular asset
            if temp.count(1) > temp.count(-1) and temp.count(1) >= 2:
                overall_signals[name] = 1
            elif temp.count(1) < temp.count(-1) and temp.count(-1) >= 2:
                overall_signals[name] = -1
            else:
                overall_signals[name] = 0

        return overall_signals

    def activate_monitoring(self, adapter: BinanceAdapter | YfinanceAdapter):

        logging.info(f'Monitoring for hourly data starting: {datetime.datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S")}')

        data, assets, positions = adapter.get_account_info()

        # Create Wallet
        wallet = Wallet(
            data['feeTier'],
            data['totalWalletBalance'],
            data['totalUnrealizedProfit'],
            data['totalMarginBalance'],
            data['totalCrossWalletBalance'],
            data['availableBalance'],
            data['maxWithdrawAmount'],
        )

        self.set_wallet(wallet)

        # Call updated rows of data
        for asset in self.assets:
            updated_df_response = adapter.get_current_df_row(asset.get_indicators(), asset.get_name())

            for x, y in updated_df_response.items():
                match x:
                    case 'atr':
                        updated_df_response[x] = ATR().calculate_historical_readings(updated_df_response[x].copy(), 5)
                    case 'bollinger':
                        updated_df_response[x] = Bollinger_Bands.BollingerBands().calculate_historical_readings(updated_df_response[x].copy(), 5)
                    case 'fibonacci':
                        updated_df_response[x] = Fibonacci.FIBONACCI().calculate_historical_readings(updated_df_response[x].copy(), 5)
                    case 'macd':
                        updated_df_response[x] = MACD().calculate_historical_readings(updated_df_response[x].copy(), 5)
                    case 'rsi':
                        updated_df_response[x] = RSI().calculate_historical_readings(updated_df_response[x].copy(), 5)
                    case 'stochastic':
                        updated_df_response[x] = Stochastic_Oscillator.StochasticOscillator().calculate_historical_readings(updated_df_response[x].copy(), 5)

            asset.set_indicators(updated_df_response)

        # Generate new time stamp TAs
        signals = self.generate_signals()

        print(signals)

        # Update weightage and notional value based on hold and buy
        self.compute_realized_allocation(signals)

        self.execute_trade(signals)

    def compute_realized_allocation(self, signals: {}):

        total_current_weights = 0.0

        # Compute total amount of weights required for denominator
        for key, value in signals.items():
            if value == 1 or value == -1:
                total_current_weights += CurrencyWeights[key].value

        # Compute each nominal individual
        for key, value in signals.items():
            for asset in self.assets:
                if asset.get_name() == key and value == 1 or value == -1:
                    new_weights = float(asset.get_weight() / total_current_weights) * float(self.wallet.total_wallet_balance)
                    asset.set_current_asset_weightage(new_weights)
                    print("Current asset weights for " + asset.get_name() + ": ", asset.get_current_asset_weightage())
                    break

    def execute_trade(self, signals: dict):
        for name, signal in signals.items():

            hedging_option = HedgingAssets.__getitem__(name).value

            # Check if asset position is available
            for asset in self.assets:

                temp_positions = []
                is_empty_array: bool
                is_long_empty_position: bool
                is_short_empty_position: bool

                # Assign temporary positions
                if asset.get_name() == name:
                    temp_positions = BinanceAdapter().get_market_positions(symbol=name)
                    is_empty_array = True if len(temp_positions) > 0 else False
                    is_long_empty_position = True if float(temp_positions[0]['positionAmt']) == 0 else False
                    is_short_empty_position = True if float(temp_positions[0]['positionAmt']) == 0 else False

                # Check for sell signals
                if signal == -1:

                    # Short if positions not available
                    if is_empty_array or is_long_empty_position and is_short_empty_position:
                        new_qty = round(asset.get_current_asset_weightage()/BinanceAdapter().get_ticker_price(name), 3)
                        new_hedge_qty = round(asset.get_current_asset_weightage()/AlpacaAdapter().get_current_ticker_data(name), 3)
                        response = self.transact_assets(symbol=name, qty=new_qty, side='SELL', position_side='SHORT')
                        hedge_response = self.transact_hedge_assets(symbol=hedging_option, qty=new_hedge_qty, side='BUY', position_side='LONG')
                        logging.info(f'Sell new short position placed for {name}')
                        logging.info(f'Buy new long hedge position placed for {hedging_option}')
                        break

                    # Check if existing short position exist
                    elif not is_short_empty_position:
                        # Skip short
                        break

                    elif not is_long_empty_position and not is_short_empty_position:
                        # If long previously, sell short positions
                        new_hedge_qty = round(temp_positions[0]['positionAmt'] / AlpacaAdapter().get_current_ticker_data(name), 3)
                        response = self.transact_assets(symbol=name, qty=temp_positions[0]['positionAmt'], side='BUY',position_side=temp_positions[0]['positionSide'])
                        hedge_response = self.transact_hedge_assets(symbol=hedging_option, qty=new_hedge_qty,side='BUY', position_side='SHORT')
                        logging.info(f'Sell SHORT position placed for {name}')
                        logging.info(f'Buy LONG hedge position placed for {hedging_option}')
                        break

                # Check for buy signals
                elif signal == 1:

                    # Sell if positions are available
                    if not is_empty_array or not is_long_empty_position and not is_short_empty_position:
                        response = self.transact_assets(symbol=name, qty=temp_positions[0]['positionAmt'], side='SELL',position_side='LONG')
                        hedge_response = self.transact_hedge_assets(symbol=hedging_option, qty=new_hedge_qty,side='BUY', position_side='SHORT')
                        logging.info(f'Sell LONG position placed for {name}')
                        logging.info(f'Buy SHORT hedge position placed for {hedging_option}')

                    # Buy back new set of assets with correct weightages
                    new_qty = round(asset.get_current_asset_weightage() / BinanceAdapter().get_ticker_price(name), 3)
                    new_hedge_qty = round(asset.get_current_asset_weightage() / AlpacaAdapter().get_current_ticker_data(name), 3)
                    response = self.transact_assets(symbol=name, qty=new_qty, side='BUY', position_side='LONG')
                    hedge_response = self.transact_hedge_assets(symbol=hedging_option, qty=new_hedge_qty, side='SELL',position_side='SHORT')
                    logging.info(f'Buy LONG position placed for {name}')
                    logging.info(f'Sell SHORT hedge position placed for {hedging_option}')
                    break

                # Hold position do not touch
                else:
                    break

    def transact_assets(self, symbol: str, qty: int, side: str, position_side: str):
        return BinanceAdapter().transact_assets(symbol=symbol, qty=qty, side=side, position_side=position_side)

    def transact_hedge_assets(self, symbol: str, qty: int, side: str):
        return AlpacaAdapter().transact_assets(symbol=symbol, qty=qty, side=side)
      
    def filter_signals(self, indicators: []):
        pass

    def __del__(self):
        pass

================================================
File: services/position.py
================================================
class Position:

    def __init__(self, symbol: str, initialMargin: float, maintMargin: float, unrealizedProfit: float, positionInitialMargin: float, openOrderInitialMargin: float,
                 leverage: float, isolated: bool, entryPrice: float, maxNotional: float, bidNotional: float, askNotional: float, positionSide: str, positionAmt: float, updateTime: float):
        self.symbol = symbol
        self.initialMargin = initialMargin
        self.maintMargin = maintMargin
        self.unrealizedProfit = unrealizedProfit
        self.positionInitialMargin = positionInitialMargin
        self.openOrderInitialMargin = openOrderInitialMargin
        self.leverage = leverage
        self.isolated = isolated
        self.entryPrice = entryPrice
        self.maxNotional = maxNotional
        self.bidNotional = bidNotional
        self.askNotional = askNotional
        self.positionSide = positionSide
        self.positionAmt = positionAmt
        self.updateTime = updateTime

    def add_pos(self):
        pass

    def get_assets(self):
        pass

    def get_notional(self):
        pass

    def __del__(self):
        pass


================================================
File: services/wallet.py
================================================
from infrastructure.interface.Binance.Iwallet import IWallet
from infrastructure.utility.Adapters.binance_adapter import BinanceAdapter


class Wallet(IWallet):

    def __init__(self, fee_tier: float, total_wallet_balance: float, total_unrealized_profit: float,
                 total_marginal_balance: float, total_cross_wallet_balance: float, available_balance: float,
                 max_withdrawal_amount: float):
        self.fee_tier = fee_tier
        self.total_wallet_balance = total_wallet_balance
        self.total_unrealized_profit = total_unrealized_profit
        self.total_marginal_balance = total_marginal_balance
        self.total_cross_wallet_balance = total_cross_wallet_balance
        self.available_balance = available_balance
        self.max_withdrawal_amount = max_withdrawal_amount

    def update_account(self) -> None:
        binance_client = BinanceAdapter()
        response = binance_client.get_account_info()
        self.fee_tier = response['feeTier']
        self.total_wallet_balance = response['totalWalletBalance']
        self.total_unrealized_profit = response['totalUnrealizedProfit']
        self.total_marginal_balance = response['totalMarginalBalance']
        self.total_cross_wallet_balance = response['totalCrossWalletBalance']
        self.available_balance = response['availableBalance']
        self.max_withdrawal_amount = response['maxWithdrawalAmount']

    def get_notional(self) -> float:
        return self.total_wallet_balance

    def get_assets(self):
        return NotImplementedError

    def __del__(self):
        pass



